

type ('a, 'b) memo = 
	| Leaf 
	| Node of ('a * 'b * ((('a, 'b) memo) ref) * ((('a, 'b) memo)) ref);;


let create_table : ('a -> 'b) -> (('a, 'b) memo ref) =
	fun _ -> ref Leaf;;


let rec find mem arg =
  match !mem with
  | Leaf -> None
  | Node (a, b, l, r) ->   if a = arg then Some b 
			   else
                             if arg < a then find l arg
	                     else
				find r arg;;


(*zalozylem ze nikt nie bedzie wstawial ekstra elementow 
wiec dla zlozonosci nie sprawdzam czy element juz jest*)
let rec insert mem a b =
  match !mem with
  | Leaf -> mem := Node(a, b, ref Leaf, ref Leaf)
  | Node (x, y, l, r) -> if a > x then	insert r a b
			else
		          insert l a b;;


let check_time f a =
  print_string "\n";
  let t = Sys.time () in
  let _ = f a in
  (Sys.time ()) -. t;;




let rec fib n =
  if n = 0 then	0
  else
    if n = 1 then 1
    else
      (fib (n-1)) + (fib (n-2));;

let how_many = 40;;
let wynik = fib how_many;;

print_float (check_time fib how_many);;


let memo_for_fib : (int, int) memo ref = ref Leaf;;

let rec fib_memo n=
  if n = 0 then	0
  else
    if n = 1 then 1
    else
      match find memo_for_fib n with
      | Some x -> x
      | None -> let wynik = (fib (n-1)) + (fib (n-2)) in
	        insert memo_for_fib n wynik; wynik;;

print_float (check_time fib_memo how_many);;
assert ((fib_memo 30) = 832040);;










type dla_fib = (int ref) * (int array ref);;

let fib_t : dla_fib = (ref 0, ref (Array.make 10 0));;

let insert : dla_fib -> int -> int -> unit =
	fun mem a b ->
		if a >= !(fst mem) then
			(
				if (Array.length !(snd mem)) < (a + 2) then
					(snd mem) := Array.append !(snd mem) (Array.make (a - Array.length !(snd mem) + 3) 0)
				else 
					();
					(fst mem) := a;
					Array.set !(snd mem) a b
			)
		else
			();;


let find : dla_fib -> int -> int option = 
	fun mem a ->
		if a < !(fst mem) then
			Some (Array.get !(snd mem) a)
		else
			None;;

let rec fib_memo : int -> int = 
	fun n -> 
		if n = 0 then
			0
		else if n = 1 then
		    1
		else 
			match find fib_t n with
			| Some x -> x
			| None -> 
				let wynik = (fib (n-1)) + (fib (n-2)) in
					insert fib_t n wynik; 
					wynik;;

print_float (check_time fib_memo how_many);;
assert ((fib_memo 30) = 832040);;

