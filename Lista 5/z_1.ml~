(* przyklady *)

type 'a llist = LNil | LCons of 'a * (unit -> 'a llist);;

let lhd = function
  LNil -> failwith "lhd"
  | LCons (x, _) -> x;;

let ltl = function
  LNil -> failwith "lhd"
  |LCons (_, xf) -> xf();;

let rec lfrom k = LCons (k, function () -> lfrom (k+1));;

let rec ltake = function
  (0, _) -> []
  | (_, LNil) -> []
  | (n, LCons(x, xf)) -> x::ltake(n-1, xf());;


let rec toLazyList = function
  [] -> LNil
  | x::xs -> LCons(x, function() -> toLazyList xs);;

let rec (@$) ll1 ll2 =
  match ll1 with
  LNil -> ll2
  | LCons(x, xf) -> LCons(x, function() -> (xf()) @$ ll2);;

let rec lmap f = function
  LNil -> LNil
  | LCons(x, xf) -> LCons(f x, function() -> lmap f (xf()) );;
  
let sqr_llist = lmap (fun x -> x*x);;

 ltake (6, sqr_llist (lfrom 3));;

 ltake( 6, lfrom 3);;

 let rec lfilter pred = function
  LNil -> LNil
  | LCons(x, xf) -> if pred x
                    then LCons (x, function() -> lfilter pred (xf()))
                    else lfilter pred (xf());;

let rec liter f x = LCons(x, function() -> liter f (f x));;

lfilter (fun x -> (x mod 2) = 0) (toLazyList (ltake (11, (lfrom 7))));;

let np = lfilter (fun x -> (x mod 2) = 1) (lfrom 1);;


(* Zadanie 1 *)

let rec lpi =
  let rec hlp k sign div = 
    LCons(k, function() ->  hlp (k +. (sign *. 4.0 /. div)) (-.sign) (div+.2.0) )
  in
  hlp 4.0 (-1.0) 3.0;;

ltake (4, (lpi ));;

let fabs = fun x -> if x<0.0 then (-1.0 *. x) else x;;
(* lfilter (fun x -> (fabs (3.141592 -. x)) < 0.0001) pi;; *)

let lmap_3 f l1 = 
  let rec hlp f = function
    (LNil, LNil, LNil) -> LNil
    | LCons(x, xf), LCons(y, yf), LCons(z, zf) -> 
      LCons (f x y z, function() -> hlp f ((xf()), (yf()), (zf())) )
  in hlp f (l1, (ltl l1), (ltl (ltl l1)));;

let euler = (fun x y z -> z -. ((y -. z) *. (y -. z)) /. (x -. (2.0 *. y) +. z ) );;

let fast_pi = lmap_3 euler lpi;;

(* LAZY *)

type 'a lazylist = LNil | LCons of 'a * 'a lazylist Lazy.t;;

let l_hd = function
  LNil -> failwith "lhd"
  | LCons (x, _) -> x;;

let l_tl = function
  LNil -> failwith "ltl"
  | LCons (_, lazy t) -> t;;

let rec l_from k = LCons (k, lazy (l_from (k+1)));;

let rec l_take = function
  (0, _) -> []
  | (_, LNil) -> []
  | (n, LCons(x,lazy xs)) -> x::l_take(n-1,xs);;

let l_pi = 
  let rec hlp k sign div = 
    let new_sign = sign *. (-1.0)
    in 
    let new_div = div +. 2.0
    in
    LCons(k, lazy (hlp (k +. (sign *. 4.0 /. div)) new_sign new_div) )
  in 
  hlp 4.0 (-1.0) 3.0;;

let l_map_3 f l1 = 
  let rec hlp f = function 
    (LNil, LNil, LNil) -> LNil
    | LCons(x, lazy xf), LCons(y, lazy yf), LCons(z, lazy zf) -> 
      LCons (f x y z, lazy (hlp f (xf, yf, zf)))
  in hlp f (l1, (l_tl l1), (l_tl (l_tl l1)));;

let fast_l_pi = l_map_3 euler l_pi;;



(*----- 2 --------*)
type move = TRANSFER of int * int | DRAIN of int | FILL of int;;
type 'a llist = LNil | LCons of 'a * (unit -> 'a llist);;
exception Error;;

let fill pair n =
  let rec fl xs n elem =
    match xs with
    |[] -> []
    |hd::tl -> if n= 0 then elem::tl
               else hd::(fl tl (n-1) elem)
  in
 ((fst pair), ( fl (snd pair) n (List.nth (fst pair) n)));;

fill ([3;5;4],[0;0;0]) 1;;

let drain pair n=
  let rec dr xs n =
    match xs with
    |[]-> []
    |hd::tl -> if n=0 then (0)::tl
               else hd::(dr tl (n-1))
  in
  ((fst pair) , (dr (snd pair) n));;

drain ([3;5;4],[1;3;0]) 1;;

let transfer pair a b =
  let b_max = List.nth (fst pair) b in
  let b_actual = List.nth (snd pair) b in
  let a_actual = List.nth (snd pair) a in
  
  let rec change xs n=
    match xs with
    |[]->[]
    |hd::tl -> if n=0 then (if b_actual+a_actual>b_max then b_max::tl
                            else (b_actual+a_actual)::tl)
               else hd::(change tl (n-1))
  in
                 
  let rec tr xs a b=
    match xs with
    |[]->[]
    |hd::tl -> match (a,b) with
               |(0,(-1))  -> if hd+b_actual < b_max+1 then (0)::tl
                             else (hd-(b_max - b_actual))::tl
               |(0, _) -> if hd+b_actual < b_max+1 then (0)::(change tl (b-1))
                          else (hd-(b_max - b_actual))::(change tl (b-1))
               |(_, 0) -> tr  (change xs 0) a (-1)
               |(_, _) -> hd::(tr tl (a-1) (b-1)) 
  in
  if a=b then pair
  else ((fst pair), (tr (snd pair) a b));;


transfer ([3;5;4],[1;3;0]) 0 1;;

transfer ([3;5;4],[1;3;0]) 1 0;;
transfer ([3;5;4],[1;3;0]) 0 0;;
transfer ([3;5;4],[1;3;0]) 1 2;;


let fill_all pair steps =
  let rec all_glasses it xs acc=
    match xs with
    | [] -> acc
    | l::ls -> all_glasses (it+1) ls (((fill pair it), (FILL(it)::steps))::acc)
  in all_glasses 0 (snd pair) [];;


let drain_all pair steps =
  let rec all_glasses it xs acc=
    match xs with
    | [] -> acc
    | l::ls -> all_glasses (it+1) ls (((drain pair it), (DRAIN(it)::steps))::acc)
  in all_glasses 0 (snd pair) [];;
 
let transfer_all pair steps =
  let len = (List.length (snd pair)) - 1 in
    let rec all_pairs nr1 nr2 acc =
      match (nr1, nr2) with
      | (x,y) when x = len -> acc
      | (x,y) when x < len && y < len -> all_pairs nr1 (nr2+1) ((transfer pair x y, TRANSFER(x,y)::steps)::acc)
      | (x,y) when x < len && y = len -> all_pairs (nr1+1) 0 ((transfer pair x y, TRANSFER(x,y)::steps)::acc)
    in all_pairs 0 0 [];;


let is_volume pair volume =
  let rec hlp xs =
    match xs with
    | [] -> false
    | x::xs -> if x = volume then true else hlp xs
  in hlp (fst pair);;

 
let rec make_moves pair res n volume =
  match List.length res with
  | x when x = n -> res
  | _ ->
    match queue with
  | [] -> raise(Error)
    | (state, moves)::rest ->
       let new_queue = rest@((fill_all pair moves)@(drain_all pair moves)@(transfer_all pair  moves))
                     rest@((fill_all state max_fill moves)@(drain_all state max_fill moves)@(transfer_all state max_fill moves))
        in
        let is_v = is_volume state volume in
          match is_v with
          | true -> make_moves new_queue max_fill ((List.rev moves)::res) n volume
          | false -> make_moves new_queue max_fill res n volume;;
 
let fqueue n =
  let rec hlp it empty =
    match it with
    | x when x = n -> empty
    | _ -> hlp (it+1) (0::empty)
  in [(hlp 0 [], [])];;
 
let rec nsols max volume n res = let newres = make_moves (max ,(fqueue (List.length glasses))) res n volume in
                                LCons(newres,
                                function()-> nsols max volume (n+1) newres);;

nsols [2;4;12] 10 5;;
